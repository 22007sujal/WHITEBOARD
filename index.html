<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pressure Sensitive Whiteboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Tesseract.js for OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <!-- PeerJS for P2P Collaboration -->
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
    
    <style>
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #18181b; 
            touch-action: none; 
            user-select: none;
            font-family: 'Inter', sans-serif;
        }

        #scroll-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }

        #pages-stack {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            min-height: 100%;
            padding-bottom: 50vh; 
            padding-top: 20px;
        }

        .page-canvas {
            display: block;
            touch-action: none;
            margin-bottom: 30px; 
            background-color: transparent;
            border-bottom: 1px dashed #3f3f46;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }
        .page-canvas:last-child {
            border-bottom: none;
        }

        .grid-bg {
            background-image: radial-gradient(#3f3f46 1px, transparent 1px);
            background-size: 24px 24px;
            background-attachment: local; 
        }

        .floating-ui {
            position: fixed; 
            z-index: 50;
            backdrop-filter: blur(8px);
            transition: opacity 0.2s;
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            padding: 0;
            overflow: hidden;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .tool-btn { transition: all 0.2s ease; }
        .tool-btn.active {
            background-color: #3b82f6; 
            color: white;
            border-color: #3b82f6;
        }

        #quick-wheel { pointer-events: none; }
        #quick-wheel.active { pointer-events: auto; }
        .wheel-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #27272a;
            border: 1px solid #3f3f46;
            color: #d4d4d8;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            transition: transform 0.1s, background 0.1s;
        }
        .wheel-btn:hover {
            transform: scale(1.1);
            background: #3f3f46;
            color: white;
        }
        .wheel-center {
            width: 50px;
            height: 50px;
            background: #3b82f6;
            color: white;
            z-index: 20;
        }
        
        #selection-ui {
            pointer-events: none;
            border: 1px dashed rgba(59, 130, 246, 0.8);
            background: rgba(59, 130, 246, 0.05);
            display: none;
            position: absolute; 
            z-index: 40;
        }
        #selection-ui.active { display: block; }
        
        #selection-actions {
            pointer-events: auto;
            position: absolute;
            top: -45px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
        }

        .cursor-pan { cursor: grab !important; }
        .cursor-panning { cursor: grabbing !important; }
        ::-webkit-scrollbar { width: 0px; background: transparent; }

        /* Top Toolbar Animations */
        #toolbar-wrapper {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #toolbar-wrapper.collapsed {
            transform: translate(-50%, -100%);
        }
        #toolbar-wrapper.collapsed #toggle-arrow {
            transform: rotate(180deg);
            top: 100%; 
            background-color: rgba(39, 39, 42, 0.9);
        }
        #toolbar-content {
            transition: opacity 0.2s;
        }
        #toolbar-wrapper.collapsed #toolbar-content {
            opacity: 0;
            pointer-events: none;
        }

        /* Right Toolbar Animations */
        #right-toolbar-wrapper {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #right-toolbar-wrapper.collapsed {
            transform: translateX(calc(100% + 1.5rem));
        }
        #right-toolbar-wrapper.collapsed #right-toggle-arrow {
            transform: translateY(-50%) rotate(180deg);
            background-color: rgba(39, 39, 42, 0.9);
        }
        #right-toolbar-content {
            transition: opacity 0.2s;
        }
        #right-toolbar-wrapper.collapsed #right-toolbar-content {
            opacity: 0;
            pointer-events: none;
        }

        /* Page Controls (Bottom Left) Animations */
        #page-controls-wrapper {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #page-controls-wrapper.collapsed {
            transform: translateX(calc(-100% - 1.5rem));
        }
        #page-controls-wrapper.collapsed #page-toggle-arrow {
            transform: translateY(-50%) rotate(180deg);
            background-color: rgba(39, 39, 42, 0.9);
        }
        #page-controls-content {
            transition: opacity 0.2s;
        }
        #page-controls-wrapper.collapsed #page-controls-content {
            opacity: 0;
            pointer-events: none;
        }

        /* Loading indicator */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #18181b; z-index: 100;
            display: flex; align-items: center; justify-content: center;
            color: #71717a; font-size: 1.2rem;
            transition: opacity 0.5s;
        }
        #loading-overlay.fade-out { opacity: 0; pointer-events: none; }
        
        /* Gesture Zone Indicator */
        #gesture-zone {
            touch-action: none;
        }

        /* Collaboration Indicator */
        .collab-active {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
            border-color: #3b82f6 !important;
        }
        .collab-status-dot {
            width: 8px; height: 8px; border-radius: 50%; background: #ef4444;
            display: inline-block; margin-right: 6px;
        }
        .collab-status-dot.online { background: #3b82f6; box-shadow: 0 0 8px #3b82f6; }
        
        /* Mic Pulse */
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }
        .mic-active {
            color: #10b981 !important;
            animation: pulse-green 2s infinite;
        }
        .mic-off {
            color: #ef4444 !important;
        }

        /* Participants Panel */
        #participants-panel {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #participants-panel.hidden-panel {
            transform: translateY(-20px);
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body id="body-bg">
    
    <!-- Loading Screen -->
    <div id="loading-overlay"><i class="fas fa-spinner fa-spin mr-3"></i> Restoring Canvas...</div>

    <!-- Text Result Modal -->
    <div id="text-result-modal" class="hidden fixed inset-0 z-[60] flex items-center justify-center bg-black/50 backdrop-blur-sm">
        <div class="bg-zinc-800 border border-zinc-700 rounded-2xl p-6 w-96 shadow-2xl relative animate-[fadeIn_0.2s_ease-out]">
            <button onclick="closeTextModal()" class="absolute top-4 right-4 text-zinc-400 hover:text-white"><i class="fas fa-times"></i></button>
            <h2 class="text-xl text-white font-semibold mb-4"><i class="fas fa-align-left mr-2 text-emerald-500"></i>Recognized Text</h2>
            <div id="text-result-content" class="bg-zinc-900/50 p-4 rounded-lg text-zinc-200 min-h-[100px] max-h-[300px] overflow-y-auto whitespace-pre-wrap font-mono text-sm border border-zinc-700/50"></div>
            <div class="mt-4 flex justify-end gap-2">
                <button onclick="closeTextModal()" class="px-4 py-2 text-zinc-400 hover:text-white text-sm font-medium">Close</button>
                <button onclick="copyTextResult()" class="px-4 py-2 bg-emerald-600 hover:bg-emerald-500 text-white rounded-lg text-sm font-medium shadow-lg transition-colors"><i class="fas fa-copy mr-2"></i>Copy Text</button>
            </div>
        </div>
    </div>

    <!-- Name Entry Modal -->
    <div id="name-modal" class="hidden fixed inset-0 z-[70] flex items-center justify-center bg-black/80 backdrop-blur-md">
        <div class="bg-zinc-900 border border-zinc-700 rounded-xl p-6 w-full max-w-sm shadow-2xl transform scale-100 transition-all">
            <h3 class="text-lg font-bold text-white mb-2"><i class="fas fa-user-tag text-blue-500 mr-2"></i>Join Session</h3>
            <p class="text-zinc-400 text-sm mb-4">Please enter your name to continue.</p>
            <input type="text" id="username-input" class="w-full bg-zinc-800 border border-zinc-600 text-white rounded-lg px-4 py-2 mb-4 outline-none focus:border-blue-500" placeholder="Your Name">
            <button onclick="submitName()" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg text-sm font-medium transition-colors">Continue</button>
        </div>
    </div>

    <!-- Share Session Modal -->
    <div id="share-modal" class="hidden fixed inset-0 z-[60] flex items-center justify-center bg-black/60 backdrop-blur-sm">
        <div class="bg-zinc-900 border border-zinc-700 rounded-xl p-6 w-full max-w-md shadow-2xl transform scale-100 transition-all">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-white"><i class="fas fa-broadcast-tower text-blue-500 mr-2"></i>Hosting Session</h3>
                <button onclick="closeShareModal()" class="text-zinc-400 hover:text-white"><i class="fas fa-times"></i></button>
            </div>
            <p class="text-zinc-400 text-sm mb-4">Share this link to invite others. Your PC acts as the server.</p>
            <div class="flex items-center gap-2 bg-zinc-800 p-2 rounded-lg border border-zinc-700 mb-4">
                <input type="text" id="share-link-input" readonly class="bg-transparent text-zinc-200 text-sm w-full outline-none px-2 font-mono">
                <button onclick="copyShareLink()" class="p-2 bg-zinc-700 hover:bg-zinc-600 rounded text-white transition-colors" title="Copy Link"><i class="fas fa-copy"></i></button>
            </div>
            <div class="flex justify-between items-center mt-4">
                <div class="text-xs text-zinc-500" id="peer-status-msg">Waiting for connections...</div>
                <button onclick="closeShareModal()" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg text-sm font-medium">Done</button>
            </div>
        </div>
    </div>

    <!-- Dedicated Gesture Zone for Page Navigation (LEFT SIDE) -->
    <div id="gesture-zone" class="fixed top-0 left-0 w-16 h-full z-40 flex flex-col justify-center items-center group hover:bg-white/5 transition-colors cursor-pointer" title="Swipe vertically here to change/add pages">
        <div class="h-16 w-1 rounded-full bg-zinc-700/50 group-hover:bg-zinc-500/80 transition-colors mb-2"></div>
        <div class="h-16 w-1 rounded-full bg-zinc-700/50 group-hover:bg-zinc-500/80 transition-colors"></div>
    </div>

    <div id="scroll-view" class="grid-bg">
        <div id="pages-stack"></div>
        
        <div id="selection-ui">
            <div id="selection-actions">
                <button onpointerdown="event.stopPropagation()" onclick="deleteSelection()" class="w-10 h-10 rounded-full bg-red-600 text-white shadow-lg flex items-center justify-center hover:bg-red-700 transition-colors" title="Delete Selection (Del)">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Quick Wheel -->
    <div id="quick-wheel" class="hidden fixed z-50 w-48 h-48 rounded-full transform -translate-x-1/2 -translate-y-1/2">
        <button onclick="hideQuickWheel()" class="wheel-btn wheel-center absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"><i class="fas fa-times"></i></button>
        <button onclick="adjustSize(2)" class="wheel-btn absolute top-0 left-1/2 transform -translate-x-1/2"><i class="fas fa-plus"></i></button>
        <button onclick="adjustSize(-2)" class="wheel-btn absolute bottom-0 left-1/2 transform -translate-x-1/2"><i class="fas fa-minus"></i></button>
        <button onclick="undo()" class="wheel-btn absolute left-0 top-1/2 transform -translate-y-1/2"><i class="fas fa-undo"></i></button>
        <button onclick="redo()" class="wheel-btn absolute right-0 top-1/2 transform -translate-y-1/2"><i class="fas fa-redo"></i></button>
        <button onclick="setQuickColor('#3b82f6')" class="wheel-btn absolute top-[15%] right-[15%]" style="background: #3b82f6; border-color: transparent;"></button>
        <button onclick="setQuickColor('#ffffff')" class="wheel-btn absolute top-[15%] left-[15%]" style="background: #ffffff; border-color: transparent;"></button>
        <button onclick="setQuickColor('#ef4444')" class="wheel-btn absolute bottom-[15%] right-[15%]" style="background: #ef4444; border-color: transparent;"></button>
        <button onclick="setTool('eraser')" class="wheel-btn absolute bottom-[15%] left-[15%]" title="Eraser"><i class="fas fa-eraser"></i></button>
    </div>

    <!-- Participants Panel (Floating Top Right) -->
    <div id="participants-panel" class="hidden-panel fixed top-20 right-6 z-40 bg-zinc-800/90 border border-zinc-700 rounded-xl p-4 w-64 shadow-xl backdrop-blur-md">
        <div class="flex justify-between items-center mb-3 border-b border-zinc-700 pb-2">
            <h4 class="text-zinc-200 font-semibold text-sm">Participants</h4>
            <span id="participant-count-badge" class="bg-zinc-700 text-zinc-300 text-xs px-2 py-0.5 rounded-full">1</span>
        </div>
        <ul id="participants-list" class="space-y-2 max-h-48 overflow-y-auto pr-1">
            <!-- List populated via JS -->
        </ul>
    </div>

    <!-- Top Toolbar Wrapper with Toggle -->
    <div id="toolbar-wrapper" class="fixed top-0 left-1/2 transform -translate-x-1/2 z-50 flex flex-col items-center pt-4">
        <div id="toolbar-content" class="bg-zinc-800/80 border border-zinc-700 rounded-full shadow-xl px-4 py-2 flex items-center gap-4 backdrop-blur-md transition-all">
            <!-- Collaboration Button -->
            <button onclick="handleCollabButton()" id="btn-collab" class="flex items-center px-3 py-1.5 rounded-full bg-zinc-700 hover:bg-zinc-600 text-zinc-300 text-xs font-medium transition-colors border border-transparent">
                <span id="collab-dot" class="collab-status-dot"></span>
                <span id="collab-text">Host</span>
            </button>
            
            <!-- Participants Toggle -->
            <button onclick="toggleParticipants()" id="btn-participants" class="hidden w-8 h-8 rounded-full text-zinc-300 hover:text-white hover:bg-zinc-700 flex items-center justify-center transition-colors" title="View Participants">
                <i class="fas fa-users"></i>
            </button>

            <!-- Mic Button (Hidden until connected) -->
            <button onclick="toggleMic()" id="btn-mic" class="hidden w-8 h-8 rounded-full text-zinc-300 hover:text-white hover:bg-zinc-700 flex items-center justify-center transition-colors" title="Toggle Microphone">
                <i class="fas fa-microphone-slash"></i>
            </button>

            <!-- Share Link Button (Hidden by default) -->
            <button onclick="showShareModal()" id="btn-share-link" class="hidden w-8 h-8 rounded-full text-zinc-300 hover:text-white hover:bg-zinc-700 flex items-center justify-center transition-colors" title="Share Session Link">
                <i class="fas fa-share-alt"></i>
            </button>

            <div class="w-px h-6 bg-zinc-600"></div>

            <div class="flex items-center gap-2 border-r border-zinc-600 pr-4">
                <button onclick="setTool('pen')" id="btn-pen" class="tool-btn active w-10 h-10 rounded-full bg-zinc-700 text-zinc-300 hover:bg-zinc-600 flex items-center justify-center" title="Pen (P)"><i class="fas fa-pen"></i></button>
                <button onclick="setTool('eraser')" id="btn-eraser" class="tool-btn w-10 h-10 rounded-full bg-zinc-700 text-zinc-300 hover:bg-zinc-600 flex items-center justify-center" title="Eraser (E)"><i class="fas fa-eraser"></i></button>
            </div>
            <div class="flex items-center gap-3 border-r border-zinc-600 pr-4">
                <input type="color" id="colorPicker" value="#ffffff" title="Color">
                <div class="flex flex-col w-24">
                    <div class="flex justify-between text-[10px] text-zinc-400 mb-1">
                        <span>Size</span>
                        <span id="sizeValue">5px</span>
                    </div>
                    <input type="range" min="1" max="50" value="5" id="sizeSlider" class="w-full accent-blue-500 h-1 bg-zinc-600 rounded-lg appearance-none cursor-pointer" oninput="updateSize(this.value)">
                </div>
            </div>
            <div class="flex items-center gap-2">
                <button onclick="undo()" class="w-8 h-8 rounded-full text-zinc-400 hover:text-white hover:bg-zinc-700 flex items-center justify-center transition-colors" title="Undo (Ctrl+Z)"><i class="fas fa-undo"></i></button>
                <button onclick="redo()" class="w-8 h-8 rounded-full text-zinc-400 hover:text-white hover:bg-zinc-700 flex items-center justify-center transition-colors" title="Redo (Ctrl+Y)"><i class="fas fa-redo"></i></button>
            </div>
        </div>
        
        <!-- Toggle Button -->
        <button onclick="toggleToolbar()" id="toggle-arrow" class="absolute -bottom-5 w-10 h-6 bg-zinc-800/80 border-b border-r border-l border-zinc-700 rounded-b-lg text-zinc-400 hover:text-white flex items-center justify-center backdrop-blur-md shadow-md transition-all">
            <i class="fas fa-chevron-up text-xs"></i>
        </button>
    </div>

    <!-- Page Controls (Bottom Left) -->
    <div id="page-controls-wrapper" class="fixed bottom-6 left-6 z-50">
        <!-- Toggle Arrow -->
        <button onclick="togglePageControls()" id="page-toggle-arrow" class="absolute top-1/2 -right-8 transform -translate-y-1/2 w-6 h-10 bg-zinc-800/80 border border-zinc-700 rounded-r-lg text-zinc-400 hover:text-white flex items-center justify-center backdrop-blur-md shadow-md transition-all">
            <i class="fas fa-chevron-left text-xs"></i>
        </button>

        <div id="page-controls-content" class="bg-zinc-800/80 border border-zinc-700 rounded-full shadow-xl px-4 py-2 flex items-center gap-3">
            <button onclick="scrollToPrevPage()" class="w-8 h-8 rounded-full text-zinc-400 hover:text-white hover:bg-zinc-700 flex items-center justify-center transition-colors"><i class="fas fa-chevron-up"></i></button>
            <span id="pageIndicator" class="text-zinc-200 text-sm font-medium w-16 text-center select-none">Page 1</span>
            <button onclick="scrollToNextPage()" class="w-8 h-8 rounded-full text-zinc-400 hover:text-white hover:bg-zinc-700 flex items-center justify-center transition-colors"><i class="fas fa-chevron-down"></i></button>
            <div class="w-px h-6 bg-zinc-600 mx-1"></div>
            <button onclick="addPage()" class="w-8 h-8 rounded-full bg-blue-600/20 text-blue-400 hover:bg-blue-600/40 flex items-center justify-center transition-colors"><i class="fas fa-plus"></i></button>
            <button onclick="deletePage()" class="w-8 h-8 rounded-full hover:bg-red-900/40 text-red-400 hover:text-red-300 flex items-center justify-center transition-colors"><i class="fas fa-times"></i></button>
        </div>
    </div>

    <!-- Right Actions Toolbar with Toggle -->
    <div id="right-toolbar-wrapper" class="fixed bottom-6 right-6 z-50">
        <!-- Toggle Arrow -->
        <button onclick="toggleRightToolbar()" id="right-toggle-arrow" class="absolute top-1/2 -left-8 transform -translate-y-1/2 w-6 h-10 bg-zinc-800/80 border border-zinc-700 rounded-l-lg text-zinc-400 hover:text-white flex items-center justify-center backdrop-blur-md shadow-md transition-all">
            <i class="fas fa-chevron-right text-xs"></i>
        </button>

        <!-- Content -->
        <div id="right-toolbar-content" class="flex flex-col gap-3 transition-opacity duration-200">
            <button onclick="toggleGrid()" class="w-12 h-12 rounded-full bg-zinc-800 border border-zinc-700 text-zinc-300 hover:bg-zinc-700 shadow-lg flex items-center justify-center transition-all" title="Toggle Grid"><i class="fas fa-border-all"></i></button>
            <button onclick="convertInkToText()" class="w-12 h-12 rounded-full bg-emerald-600 text-white hover:bg-emerald-700 shadow-lg flex items-center justify-center transition-all" title="Convert to Text"><i class="fas fa-font"></i></button>
            <button onclick="clearCanvas()" class="w-12 h-12 rounded-full bg-red-900/50 border border-red-800 text-red-200 hover:bg-red-900/80 shadow-lg flex items-center justify-center transition-all" title="Clear Page"><i class="fas fa-trash-alt"></i></button>
            <button onclick="downloadPDF()" class="w-12 h-12 rounded-full bg-indigo-600 text-white hover:bg-indigo-700 shadow-lg flex items-center justify-center transition-all" title="Download All as PDF"><i class="fas fa-file-pdf"></i></button>
            <button onclick="downloadCanvas()" class="w-12 h-12 rounded-full bg-blue-600 text-white hover:bg-blue-700 shadow-lg flex items-center justify-center transition-all" title="Download Image"><i class="fas fa-image"></i></button>
        </div>
    </div>

    <!-- Hidden audio container for remote streams -->
    <div id="remote-audio-container" class="hidden"></div>

    <script>
        const pagesStack = document.getElementById('pages-stack');
        const scrollView = document.getElementById('scroll-view');
        const quickWheel = document.getElementById('quick-wheel');
        const selectionUi = document.getElementById('selection-ui');
        const gestureZone = document.getElementById('gesture-zone');
        const audioContainer = document.getElementById('remote-audio-container');
        
        let state = {
            mode: 'IDLE', 
            lastX: 0, lastY: 0,
            tool: 'pen', color: '#ffffff', baseSize: 5, pressureEnabled: true,
            isSpaceBarDown: false,
            startScrollTop: 0, startScrollLeft: 0,
            pages: [], activePageIndex: 0, 
            lassoPath: [], lassoSnapshot: null, 
            selection: { active: false, pageIndex: -1, x: 0, y: 0, w: 0, h: 0, image: null },
            strokeStartX: 0, strokeStartY: 0, strokeStartTime: 0, 
            
            // P2P State
            isHost: false,
            peer: null,
            connections: [],
            roomId: null,
            currentStrokePoints: [],
            
            // User Info
            username: "Guest",
            pendingRoomId: null, // If joining via link
            participants: [], // List of {id, name}

            // Voice State
            localStream: null,
            isMicOn: false
        };

        const MAX_HISTORY = 30;
        let baseCanvas = document.createElement('canvas');
        let baseCtx = baseCanvas.getContext('2d');
        let saveTimeout = null;

        function init() {
            // Check for room param
            const urlParams = new URLSearchParams(window.location.search);
            const roomParam = urlParams.get('room');

            if (!roomParam && localStorage.getItem('wb_data')) {
                loadFromStorage();
            } else {
                addPage();
                document.getElementById('loading-overlay').classList.add('fade-out');
            }

            if (roomParam) {
                // If room param exists, trigger name modal flow
                state.pendingRoomId = roomParam;
                document.getElementById('collab-text').textContent = "Join Session...";
                showNameModal();
            }

            setupObserver();
            setupGlobalEvents();
        }

        // --- NAME MODAL LOGIC ---
        function showNameModal() {
            document.getElementById('name-modal').classList.remove('hidden');
            document.getElementById('username-input').focus();
        }

        function submitName() {
            const input = document.getElementById('username-input');
            const name = input.value.trim();
            if (name) {
                state.username = name;
                document.getElementById('name-modal').classList.add('hidden');
                
                if (state.pendingRoomId) {
                    // Completing a join flow
                    joinSession(state.pendingRoomId);
                    state.pendingRoomId = null;
                } else {
                    // Completing a host flow
                    startHosting();
                }
            } else {
                input.classList.add('border-red-500');
            }
        }

        // --- P2P LOGIC START ---

        function handleCollabButton() {
            if (state.peer && !state.peer.destroyed) {
                showShareModal();
            } else {
                // Start hosting flow -> ask name first
                showNameModal();
            }
        }

        function startHosting() {
            const btn = document.getElementById('btn-collab');
            const dot = document.getElementById('collab-dot');
            const txt = document.getElementById('collab-text');
            
            txt.textContent = "Starting...";

            state.isHost = true;
            state.roomId = 'wb-' + Math.random().toString(36).substr(2, 9);
            
            // Add self to participants list
            updateParticipantsList([{ id: 'host', name: state.username + " (You)", isHost: true }]);

            state.peer = new Peer(state.roomId, {
                debug: 1,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun.services.mozilla.com' }
                    ]
                }
            });

            state.peer.on('open', (id) => {
                console.log('My peer ID is: ' + id);
                txt.textContent = "Hosting";
                dot.classList.add('online');
                document.getElementById('toolbar-content').classList.add('collab-active');
                document.getElementById('btn-share-link').classList.remove('hidden');
                document.getElementById('btn-mic').classList.remove('hidden');
                document.getElementById('btn-participants').classList.remove('hidden');
                
                try {
                    const newUrl = window.location.pathname + '?room=' + id;
                    window.history.pushState({ path: newUrl }, '', newUrl);
                } catch(e) { console.log("Sandbox mode: URL update blocked"); }
                
                showShareModal();
            });

            state.peer.on('connection', (conn) => {
                console.log('Peer connected:', conn.peer);
                setupConnection(conn);
            });
            
            state.peer.on('call', handleIncomingCall);

            state.peer.on('error', (err) => {
                console.error(err);
                alert("P2P Error: " + err.type);
                txt.textContent = "Host";
            });
        }

        function joinSession(roomId) {
            const btn = document.getElementById('btn-collab');
            const dot = document.getElementById('collab-dot');
            const txt = document.getElementById('collab-text');
            
            txt.textContent = "Joining...";
            state.roomId = roomId;
            state.isHost = false;

            state.peer = new Peer(null, {
                debug: 1,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun.services.mozilla.com' }
                    ]
                }
            });

            state.peer.on('open', (id) => {
                const conn = state.peer.connect(roomId, { reliable: true });
                setupConnection(conn);
            });
            
            state.peer.on('call', handleIncomingCall);

            state.peer.on('error', (err) => {
                console.error(err);
                txt.textContent = "Error";
                alert("Could not join session. Host might be offline.");
            });
        }

        function setupConnection(conn) {
            const dot = document.getElementById('collab-dot');
            const txt = document.getElementById('collab-text');

            conn.on('open', () => {
                console.log("Connection established");
                state.connections.push(conn);
                txt.textContent = state.isHost ? "Hosting" : "Joined";
                dot.classList.add('online');
                document.getElementById('toolbar-content').classList.add('collab-active');
                if(state.isHost) document.getElementById('btn-share-link').classList.remove('hidden');
                document.getElementById('btn-mic').classList.remove('hidden');
                document.getElementById('btn-participants').classList.remove('hidden');
                
                // === HANDSHAKE LOGIC ===
                if (state.isHost) {
                    // Host waits for guest name
                    // Host calls if mic is already on
                    if (state.localStream && state.isMicOn) {
                        const call = state.peer.call(conn.peer, state.localStream);
                        handleOutgoingCall(call);
                    }
                    setTimeout(() => sendInitialState(conn), 500);
                } else {
                    // Guest sends name immediately
                    conn.send({ type: 'join', name: state.username });
                }
            });

            conn.on('data', (data) => {
                handlePeerData(data, conn);
            });

            conn.on('close', () => {
                state.connections = state.connections.filter(c => c !== conn);
                if (state.connections.length === 0 && !state.isHost) {
                    txt.textContent = "Disconnected";
                    dot.classList.remove('online');
                } else if (state.isHost) {
                    // Remove participant
                    state.participants = state.participants.filter(p => p.id !== conn.peer);
                    updateParticipantsList(state.participants);
                    broadcast({ type: 'update_participants', list: state.participants });
                }
            });
        }

        // --- Participant Logic ---
        function toggleParticipants() {
            const p = document.getElementById('participants-panel');
            p.classList.toggle('hidden-panel');
        }

        function updateParticipantsList(list) {
            state.participants = list;
            const ul = document.getElementById('participants-list');
            const count = document.getElementById('participant-count-badge');
            ul.innerHTML = '';
            count.textContent = list.length;

            list.forEach(p => {
                const li = document.createElement('li');
                li.className = 'flex items-center gap-2 text-zinc-300 text-sm';
                li.innerHTML = `
                    <div class="w-6 h-6 rounded-full bg-zinc-700 flex items-center justify-center text-xs font-bold text-blue-400">
                        ${p.name.charAt(0).toUpperCase()}
                    </div>
                    <span>${p.name}</span>
                    ${p.isHost ? '<span class="text-[10px] bg-blue-900 text-blue-200 px-1 rounded">HOST</span>' : ''}
                `;
                ul.appendChild(li);
            });
        }

        // --- Voice Chat Logic ---

        async function toggleMic() {
            const btn = document.getElementById('btn-mic');
            const icon = btn.querySelector('i');

            if (!state.localStream) {
                // First click: Request Permission
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    state.localStream = stream;
                    state.isMicOn = true;
                    
                    icon.className = 'fas fa-microphone';
                    btn.classList.add('mic-active');
                    
                    if (state.isHost) {
                        state.connections.forEach(conn => {
                            const call = state.peer.call(conn.peer, stream);
                            handleOutgoingCall(call);
                        });
                    } else {
                        const call = state.peer.call(state.roomId, stream);
                        handleOutgoingCall(call);
                    }
                    
                } catch (err) {
                    console.error("Microphone access denied:", err);
                    alert("Could not access microphone. Please allow permissions.");
                }
            } else {
                state.isMicOn = !state.isMicOn;
                state.localStream.getAudioTracks().forEach(track => track.enabled = state.isMicOn);
                
                if (state.isMicOn) {
                    icon.className = 'fas fa-microphone';
                    btn.classList.add('mic-active');
                    btn.classList.remove('mic-off');
                } else {
                    icon.className = 'fas fa-microphone-slash';
                    btn.classList.remove('mic-active');
                    btn.classList.add('mic-off');
                }
            }
        }

        function handleOutgoingCall(call) {
            call.on('stream', (remoteStream) => playRemoteStream(remoteStream));
            call.on('error', err => console.error("Call error:", err));
        }

        function handleIncomingCall(call) {
            console.log("Incoming call from:", call.peer);
            if (state.localStream) {
                call.answer(state.localStream);
            } else {
                call.answer();
            }
            call.on('stream', (remoteStream) => playRemoteStream(remoteStream));
        }

        function playRemoteStream(stream) {
            if (document.getElementById(`audio-${stream.id}`)) return;
            const audio = document.createElement('audio');
            audio.id = `audio-${stream.id}`;
            audio.srcObject = stream;
            audio.autoplay = true;
            audio.playsInline = true; 
            audioContainer.appendChild(audio);
            
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    const unlock = () => { audio.play(); document.removeEventListener('click', unlock); };
                    document.addEventListener('click', unlock);
                });
            }
        }

        // --- Data Handling ---

        function sendInitialState(conn) {
            const pagesData = state.pages.map(p => p.canvas.toDataURL());
            conn.send({
                type: 'init',
                pages: pagesData,
                activeIndex: state.activePageIndex,
                participants: state.participants // Send current list to new joiner
            });
        }

        function broadcast(data) {
            state.connections.forEach(conn => { if (conn.open) conn.send(data); });
        }

        function handlePeerData(data, conn) {
            if (data.type === 'join') {
                // Host received join request
                const newPeer = { id: conn.peer, name: data.name, isHost: false };
                // Add to list if not exists
                if (!state.participants.find(p => p.id === newPeer.id)) {
                    state.participants.push(newPeer);
                    updateParticipantsList(state.participants);
                    broadcast({ type: 'update_participants', list: state.participants });
                }

            } else if (data.type === 'update_participants') {
                // Guest received updated list
                updateParticipantsList(data.list);

            } else if (data.type === 'init') {
                while(state.pages.length > 0) { const p = state.pages.pop(); p.canvas.remove(); }
                pagesStack.innerHTML = '';
                
                data.pages.forEach((imgData, idx) => {
                    const { canvas, ctx } = createPageCanvas(idx);
                    pagesStack.appendChild(canvas);
                    state.pages.push({ id: `page-${idx}`, canvas, ctx, history: [imgData], historyStep: 0 });
                    const img = new Image();
                    img.onload = () => ctx.drawImage(img, 0, 0, canvas.width / (window.devicePixelRatio||1), canvas.height / (window.devicePixelRatio||1));
                    img.src = imgData;
                });
                state.activePageIndex = data.activeIndex || 0;
                updatePageIndicator();
                setTimeout(() => state.pages[state.activePageIndex]?.canvas.scrollIntoView(), 100);
                
                // Handle initial participant list sync
                if (data.participants) updateParticipantsList(data.participants);

            } else if (data.type === 'stroke') {
                drawRemoteStroke(data);
            } else if (data.type === 'add_page') {
                addPage(false); 
            } else if (data.type === 'page_change') {
                state.activePageIndex = data.index;
                updatePageIndicator();
                state.pages[data.index]?.canvas.scrollIntoView({ behavior: 'smooth' });
            }
        }

        function drawRemoteStroke(strokeData) {
            while (state.pages.length <= strokeData.pageIndex) addPage(false);
            const page = state.pages[strokeData.pageIndex];
            const ctx = page.ctx;
            const points = strokeData.points;
            if (!points || points.length < 2) return;

            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (strokeData.tool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = strokeData.baseSize * 3;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = strokeData.color;
            }

            for (let i = 1; i < points.length; i++) {
                const p1 = points[i-1];
                const p2 = points[i];
                const pressure = p2.p || 0.5;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                if (strokeData.tool !== 'eraser') ctx.lineWidth = Math.max(0.5, strokeData.baseSize * pressure * 2);
                ctx.stroke();
            }
            ctx.restore();
        }

        // --- UI Logic for Share Modal ---
        function showShareModal() {
            const input = document.getElementById('share-link-input');
            let url = window.location.href;
            if (state.roomId && !url.includes(state.roomId)) {
                const separator = url.includes('?') ? '&' : '?';
                url = url.split('?')[0] + separator + 'room=' + state.roomId;
            }
            input.value = url;
            document.getElementById('share-modal').classList.remove('hidden');
        }

        function closeShareModal() { document.getElementById('share-modal').classList.add('hidden'); }
        function copyShareLink() {
            const input = document.getElementById('share-link-input');
            input.select();
            document.execCommand('copy');
        }

        // --- Core App Logic ---

        function createPageCanvas(index) {
            const canvas = document.createElement('canvas');
            canvas.className = 'page-canvas';
            canvas.id = `page-${index}`;
            const dpr = window.devicePixelRatio || 1;
            const width = Math.max(1, window.innerWidth);
            const height = Math.max(1, window.innerHeight);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            const ctx = canvas.getContext('2d'); 
            ctx.scale(dpr, dpr);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            return { canvas, ctx };
        }

        function toggleToolbar() { document.getElementById('toolbar-wrapper').classList.toggle('collapsed'); }
        function toggleRightToolbar() { document.getElementById('right-toolbar-wrapper').classList.toggle('collapsed'); }
        function togglePageControls() { document.getElementById('page-controls-wrapper').classList.toggle('collapsed'); }

        function triggerSave() { clearTimeout(saveTimeout); saveTimeout = setTimeout(saveToStorage, 1000); }

        function saveToStorage() {
            if (state.roomId) return;
            try {
                const data = {
                    activePageIndex: state.activePageIndex,
                    pages: state.pages.map(p => p.canvas.toDataURL())
                };
                localStorage.setItem('wb_data', JSON.stringify(data));
            } catch (e) { console.warn('Storage quota', e); }
        }

        function loadFromStorage() {
            try {
                const data = JSON.parse(localStorage.getItem('wb_data'));
                if (!data || !data.pages || data.pages.length === 0) { addPage(); document.getElementById('loading-overlay').classList.add('fade-out'); return; }
                let loadedCount = 0;
                data.pages.forEach((dataURL, index) => {
                    const { canvas, ctx } = createPageCanvas(index);
                    pagesStack.appendChild(canvas);
                    const pageObj = { id: `page-${index}`, canvas, ctx, history: [dataURL], historyStep: 0 };
                    state.pages.push(pageObj);
                    const img = new Image();
                    img.onload = () => { ctx.drawImage(img, 0, 0, canvas.width / (window.devicePixelRatio||1), canvas.height / (window.devicePixelRatio||1)); loadedCount++; if (loadedCount === data.pages.length) document.getElementById('loading-overlay').classList.add('fade-out'); };
                    img.src = dataURL;
                });
                state.activePageIndex = Math.min(data.activePageIndex, state.pages.length - 1);
                updatePageIndicator();
                setTimeout(() => state.pages[state.activePageIndex]?.canvas.scrollIntoView(), 100);
            } catch (e) { addPage(); document.getElementById('loading-overlay').classList.add('fade-out'); }
        }

        function addPage(shouldBroadcast = true) {
            if(state.selection.active) stampSelection();
            const index = state.pages.length;
            const { canvas, ctx } = createPageCanvas(index);
            pagesStack.appendChild(canvas);
            state.pages.push({ id: `page-${index}`, canvas: canvas, ctx: ctx, history: [], historyStep: -1 });
            saveStateToPage(index);
            if (index > 0) setTimeout(() => canvas.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
            if(shouldBroadcast && state.roomId) { broadcast({ type: 'add_page' }); broadcast({ type: 'page_change', index: index }); }
            if (!state.roomId) triggerSave();
        }

        function deletePage() {
            if(state.selection.active) stampSelection();
            if (state.pages.length <= 1) { clearCanvas(); return; }
            const indexToDelete = state.activePageIndex;
            const pageObj = state.pages[indexToDelete];
            if (pageObj && pageObj.canvas) { pageObj.canvas.remove(); state.pages.splice(indexToDelete, 1); state.activePageIndex = Math.max(0, indexToDelete - 1); }
            updatePageIndicator();
            triggerSave();
        }

        function scrollToNextPage() {
            const nextIndex = state.activePageIndex + 1;
            if (nextIndex < state.pages.length) { state.pages[nextIndex].canvas.scrollIntoView({ behavior: 'smooth', block: 'start' }); if(state.roomId) broadcast({ type: 'page_change', index: nextIndex }); }
        }
        function scrollToPrevPage() {
            const prevIndex = state.activePageIndex - 1;
            if (prevIndex >= 0) { state.pages[prevIndex].canvas.scrollIntoView({ behavior: 'smooth', block: 'start' }); if(state.roomId) broadcast({ type: 'page_change', index: prevIndex }); }
        }

        function resize() {
            if(state.selection.active) stampSelection();
            const dpr = window.devicePixelRatio || 1;
            const width = Math.max(1, window.innerWidth);
            const height = Math.max(1, window.innerHeight);
            state.pages.forEach(page => {
                let tempCanvas = null;
                if (page.canvas.width > 0) { tempCanvas = document.createElement('canvas'); tempCanvas.width = page.canvas.width; tempCanvas.height = page.canvas.height; tempCanvas.getContext('2d').drawImage(page.canvas, 0, 0); }
                page.canvas.style.width = `${width}px`; page.canvas.style.height = `${height}px`; page.canvas.width = width * dpr; page.canvas.height = height * dpr;
                page.ctx.scale(dpr, dpr); page.ctx.lineCap = 'round'; page.ctx.lineJoin = 'round';
                if (tempCanvas) page.ctx.drawImage(tempCanvas, 0, 0, width, height);
            });
            baseCanvas.width = width * dpr; baseCanvas.height = height * dpr;
        }
        window.addEventListener('resize', resize);

        function setupObserver() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => { if (entry.isIntersecting) { const idx = state.pages.findIndex(p => p.canvas === entry.target); if (idx !== -1) { state.activePageIndex = idx; updatePageIndicator(); } } });
            }, { threshold: 0.5 });
            const originalAddPage = addPage;
            state.pages.forEach(p => observer.observe(p.canvas));
            const existingAddPage = addPage;
            addPage = function(shouldBroadcast=true) {
                 if(state.selection.active) stampSelection();
                 const index = state.pages.length; const { canvas, ctx } = createPageCanvas(index); pagesStack.appendChild(canvas);
                 state.pages.push({ id: `page-${index}`, canvas: canvas, ctx: ctx, history: [], historyStep: -1 });
                 saveStateToPage(index); observer.observe(canvas);
                 if (index > 0) setTimeout(() => canvas.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
                 if(shouldBroadcast && state.roomId) { broadcast({ type: 'add_page' }); broadcast({ type: 'page_change', index: index }); }
                 if(!state.roomId) triggerSave();
            }
        }
        function updatePageIndicator() { document.getElementById('pageIndicator').textContent = `Page ${state.activePageIndex + 1}`; }

        function setupGlobalEvents() {
            scrollView.addEventListener('contextmenu', e => e.preventDefault());
            scrollView.addEventListener('pointerdown', handlePointerDown);
            window.addEventListener('pointermove', handlePointerMove);
            window.addEventListener('pointerup', handlePointerUp);
            gestureZone.addEventListener('pointerdown', (e) => { e.preventDefault(); e.stopPropagation(); gestureZone.setPointerCapture(e.pointerId); state.mode = 'GESTURE_SWIPE'; state.strokeStartY = e.clientY; state.strokeStartTime = Date.now(); });
        }

        function getEventInfo(e) {
            let targetCanvas = e.target;
            if (targetCanvas.closest('#selection-ui')) { if (state.selection.pageIndex !== -1) targetCanvas = state.pages[state.selection.pageIndex].canvas; }
            if (!targetCanvas || targetCanvas.tagName !== 'CANVAS') return null;
            const pageIndex = state.pages.findIndex(p => p.canvas === targetCanvas); if (pageIndex === -1) return null;
            const rect = targetCanvas.getBoundingClientRect();
            return { pageIndex, x: e.clientX - rect.left, y: e.clientY - rect.top, pressure: e.pressure, rect: rect };
        }

        function handlePointerDown(e) {
            if (state.isSpaceBarDown) { state.mode = 'PANNING'; state.lastX = e.clientX; state.lastY = e.clientY; state.startScrollTop = scrollView.scrollTop; scrollView.classList.add('cursor-panning'); return; }
            const info = getEventInfo(e);
            if (e.button === 2 || e.button === 5) { state.activePageIndex = info ? info.pageIndex : state.activePageIndex; state.mode = 'LASSO_WAIT'; state.menuX = e.clientX; state.menuY = e.clientY; if(info) { const page = state.pages[info.pageIndex]; if(page) state.lassoSnapshot = page.ctx.getImageData(0, 0, page.canvas.width, page.canvas.height); state.lassoPath = [{x: info.x, y: info.y}]; state.lastX = info.x; state.lastY = info.y; } hideQuickWheel(); return; }
            if (!info) return;
            state.activePageIndex = info.pageIndex; updatePageIndicator();
            if (state.selection.active && state.selection.pageIndex === info.pageIndex) { const s = state.selection; if (info.x >= s.x && info.x <= s.x + s.w && info.y >= s.y && info.y <= s.y + s.h) { if (e.buttons === 1) { liftSelection(); state.mode = 'MOVING_SELECTION'; state.lastX = info.x; state.lastY = info.y; renderSelectionMove(); return; } } else stampSelection(); } else if (state.selection.active) stampSelection();
            if (e.buttons === 1) { state.mode = 'DRAWING'; state.lastX = info.x; state.lastY = info.y; state.strokeStartX = e.clientX; state.strokeStartY = e.clientY; state.strokeStartTime = Date.now(); state.currentStrokePoints = [{ x: info.x, y: info.y, p: info.pressure || 0.5 }]; draw(e, info.pageIndex); } else if (e.button === 1) { e.preventDefault(); toggleEraser(); }
        }

        function handlePointerMove(e) {
            if (state.mode === 'PANNING') { scrollView.scrollTop = state.startScrollTop - (e.clientY - state.lastY); return; }
            const info = getEventInfo(e);
            if (state.mode === 'MOVING_SELECTION') { if (!info || info.pageIndex !== state.selection.pageIndex) return; state.selection.x += info.x - state.lastX; state.selection.y += info.y - state.lastY; state.lastX = info.x; state.lastY = info.y; updateSelectionVisuals(); renderSelectionMove(); } 
            else if (state.mode === 'LASSO_WAIT') { if (!info) return; if (Math.hypot(info.x - state.lastX, info.y - state.lastY) > 5) state.mode = 'LASSOING'; }
            if (state.mode === 'LASSOING' && info && info.pageIndex === state.activePageIndex) { const page = state.pages[state.activePageIndex]; if(state.lassoSnapshot) page.ctx.putImageData(state.lassoSnapshot, 0, 0); state.lassoPath.push({x: info.x, y: info.y}); redrawLassoPath(state.activePageIndex); } 
            else if (state.mode === 'DRAWING' && info && info.pageIndex === state.activePageIndex) draw(e, info.pageIndex);
        }

        function handlePointerUp(e) {
            if (state.mode === 'PANNING') { state.mode = 'IDLE'; scrollView.classList.remove('cursor-panning'); } 
            else if (state.mode === 'LASSO_WAIT') { state.mode = 'IDLE'; state.lassoSnapshot = null; showQuickWheel(state.menuX, state.menuY); } 
            else if (state.mode === 'LASSOING') { finishLassoSelection(); state.mode = 'IDLE'; } 
            else if (state.mode === 'MOVING_SELECTION') { state.mode = 'SELECTION_ACTIVE'; } 
            else if (state.mode === 'GESTURE_SWIPE') { const dy = e.clientY - state.strokeStartY; const duration = Date.now() - state.strokeStartTime; if (duration < 800 && Math.abs(dy) > 50) { if (dy < 0) { if (state.activePageIndex === state.pages.length - 1) addPage(); else scrollToNextPage(); } else { scrollToPrevPage(); } } state.mode = 'IDLE'; if(gestureZone.hasPointerCapture(e.pointerId)) gestureZone.releasePointerCapture(e.pointerId); } 
            else if (state.mode === 'DRAWING') { state.mode = 'IDLE'; const page = state.pages[state.activePageIndex]; if (page) { page.ctx.beginPath(); saveStateToPage(state.activePageIndex); if (state.roomId && state.currentStrokePoints.length > 1) { broadcast({ type: 'stroke', points: state.currentStrokePoints, color: state.color, baseSize: state.baseSize, tool: state.tool, pageIndex: state.activePageIndex }); } else { triggerSave(); } state.currentStrokePoints = []; } }
        }

        function draw(e, pageIndex) {
            const page = state.pages[pageIndex]; if (!page) return;
            const rect = page.canvas.getBoundingClientRect();
            const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
            events.forEach(event => {
                const x = event.clientX - rect.left; const y = event.clientY - rect.top;
                const pressure = (event.pointerType === 'pen' && state.pressureEnabled) ? event.pressure : 0.5;
                if (state.mode === 'DRAWING') { state.currentStrokePoints.push({ x: Math.round(x), y: Math.round(y), p: parseFloat(pressure.toFixed(2)) }); }
                page.ctx.beginPath(); page.ctx.moveTo(state.lastX, state.lastY); page.ctx.lineTo(x, y);
                if (state.tool === 'eraser') { page.ctx.globalCompositeOperation = 'destination-out'; page.ctx.lineWidth = state.baseSize * 3; } 
                else { page.ctx.globalCompositeOperation = 'source-over'; page.ctx.strokeStyle = state.color; page.ctx.lineWidth = Math.max(0.5, event.pointerType === 'pen' ? (state.baseSize * pressure * 2) : state.baseSize); }
                page.ctx.stroke(); state.lastX = x; state.lastY = y;
            });
        }

        function redrawLassoPath(pageIndex) {
            const page = state.pages[pageIndex]; if(!page || state.lassoPath.length < 2) return;
            page.ctx.save(); page.ctx.globalCompositeOperation = 'source-over'; page.ctx.strokeStyle = '#3b82f6'; page.ctx.lineWidth = 1; page.ctx.setLineDash([5, 5]); page.ctx.beginPath(); state.lassoPath.forEach((p, i) => { i===0 ? page.ctx.moveTo(p.x, p.y) : page.ctx.lineTo(p.x, p.y); }); page.ctx.stroke(); page.ctx.restore();
        }

        function finishLassoSelection() { /* ... unchanged ... */
            const page = state.pages[state.activePageIndex];
            if (state.lassoSnapshot && page) { page.ctx.putImageData(state.lassoSnapshot, 0, 0); state.lassoSnapshot = null; }
            if (state.lassoPath.length < 3) return;
            let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
            state.lassoPath.forEach(p => { if(p.x < minX) minX=p.x; if(p.x > maxX) maxX=p.x; if(p.y < minY) minY=p.y; if(p.y > maxY) maxY=p.y; });
            const w = maxX - minX, h = maxY - minY;
            if (w <= 0 || h <= 0) return;
            state.selection = { active: true, pageIndex: state.activePageIndex, x: minX, y: minY, w: w, h: h, image: null };
            state.mode = 'SELECTION_ACTIVE';
            updateSelectionVisuals();
        }

        function liftSelection() { /* ... unchanged ... */
            if (state.selection.image) return;
            const page = state.pages[state.selection.pageIndex];
            const s = state.selection;
            const dpr = window.devicePixelRatio || 1;
            let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
            state.lassoPath.forEach(p => { const px = p.x * dpr, py = p.y * dpr; if (px < minX) minX = px; if (px > maxX) maxX = px; if (py < minY) minY = py; if (py > maxY) maxY = py; });
            const pad = 5 * dpr; minX = Math.floor(minX - pad); minY = Math.floor(minY - pad); maxX = Math.ceil(maxX + pad); maxY = Math.ceil(maxY + pad);
            const w = maxX - minX, h = maxY - minY;
            if (w <= 0 || h <= 0) return;
            s.x = minX / dpr; s.y = minY / dpr; s.w = w / dpr; s.h = h / dpr;
            const selCanvas = document.createElement('canvas'); selCanvas.width = w; selCanvas.height = h; const selCtx = selCanvas.getContext('2d');
            selCtx.drawImage(page.canvas, -minX, -minY);
            selCtx.globalCompositeOperation = 'destination-in'; selCtx.beginPath();
            state.lassoPath.forEach((p, i) => { const tx = (p.x * dpr) - minX, ty = (p.y * dpr) - minY; i===0 ? selCtx.moveTo(tx, ty) : selCtx.lineTo(tx, ty); });
            selCtx.closePath(); selCtx.fillStyle = '#000000'; selCtx.fill();
            s.image = selCanvas;
            page.ctx.save(); page.ctx.setTransform(1, 0, 0, 1, 0, 0); page.ctx.globalCompositeOperation = 'destination-out'; page.ctx.beginPath();
            state.lassoPath.forEach((p, i) => { const tx = p.x * dpr, ty = p.y * dpr; i===0 ? page.ctx.moveTo(tx, ty) : page.ctx.lineTo(tx, ty); });
            page.ctx.fillStyle = '#000000'; page.ctx.fill(); page.ctx.restore();
            baseCanvas.width = page.canvas.width; baseCanvas.height = page.canvas.height; baseCtx.clearRect(0,0, baseCanvas.width, baseCanvas.height); baseCtx.drawImage(page.canvas, 0, 0);
        }

        async function downloadPDF() { /* ... unchanged ... */
            if(state.selection.active) stampSelection();
            const { jsPDF } = window.jspdf;
            const width = window.innerWidth; const height = window.innerHeight; const orientation = width > height ? 'l' : 'p';
            const pdf = new jsPDF({ orientation: orientation, unit: 'px', format: [width, height] });
            for (let i = 0; i < state.pages.length; i++) { if (i > 0) pdf.addPage([width, height], orientation); const page = state.pages[i]; const composite = getCompositedCanvas(page.canvas); const imgData = composite.toDataURL('image/jpeg', 0.95); pdf.addImage(imgData, 'JPEG', 0, 0, width, height); }
            pdf.save('whiteboard-export.pdf');
        }

        async function convertInkToText() { /* ... unchanged ... */
            if(state.selection.active) stampSelection();
            const page = state.pages[state.activePageIndex];
            if(!page) return;
            const loading = document.getElementById('loading-overlay');
            const originalText = loading.innerHTML;
            loading.innerHTML = '<i class="fas fa-spinner fa-spin mr-3"></i> Processing Text...';
            loading.classList.remove('fade-out');
            try {
                const tempCanvas = document.createElement('canvas'); tempCanvas.width = page.canvas.width; tempCanvas.height = page.canvas.height; const tCtx = tempCanvas.getContext('2d');
                tCtx.drawImage(page.canvas, 0, 0); tCtx.globalCompositeOperation = 'source-in'; tCtx.fillStyle = '#000000'; tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                const finalCanvas = document.createElement('canvas'); finalCanvas.width = page.canvas.width; finalCanvas.height = page.canvas.height; const fCtx = finalCanvas.getContext('2d');
                fCtx.fillStyle = '#ffffff'; fCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height); fCtx.drawImage(tempCanvas, 0, 0);
                const { data: { text } } = await Tesseract.recognize(finalCanvas, 'eng');
                document.getElementById('text-result-content').textContent = text.trim() || "No text detected.";
                document.getElementById('text-result-modal').classList.remove('hidden');
            } catch (e) { console.error(e); alert("Failed to recognize text."); } finally { loading.classList.add('fade-out'); setTimeout(() => loading.innerHTML = originalText, 500); }
        }

        function closeTextModal() { document.getElementById('text-result-modal').classList.add('hidden'); }
        function copyTextResult() { navigator.clipboard.writeText(document.getElementById('text-result-content').textContent); closeTextModal(); }
        
        function setTool(t) { if(state.selection.active) stampSelection(); state.tool = t; document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active')); document.getElementById(`btn-${t}`).classList.add('active'); }
        function toggleEraser() { setTool(state.tool === 'eraser' ? 'pen' : 'eraser'); }
        function updateSize(v) { state.baseSize = parseInt(v); document.getElementById('sizeValue').textContent = v + 'px'; }
        document.getElementById('colorPicker').addEventListener('input', e => { state.color = e.target.value; setTool('pen'); });
        
        function showQuickWheel(x, y) { quickWheel.style.left = `${x}px`; quickWheel.style.top = `${y}px`; quickWheel.classList.remove('hidden'); quickWheel.classList.add('active'); }
        function hideQuickWheel() { quickWheel.classList.add('hidden'); quickWheel.classList.remove('active'); }
        function setQuickColor(c) { state.color = c; document.getElementById('colorPicker').value = c; setTool('pen'); hideQuickWheel(); }
        function adjustSize(delta) { let s = state.baseSize + delta; s = Math.max(1, Math.min(50, s)); updateSize(s); document.getElementById('sizeSlider').value = s; }
        function toggleGrid() { scrollView.classList.toggle('grid-bg'); }

        function saveStateToPage(pageIndex) {
            const page = state.pages[pageIndex]; if (!page) return;
            if (page.historyStep < page.history.length - 1) page.history = page.history.slice(0, page.historyStep + 1);
            page.history.push(page.canvas.toDataURL()); if (page.history.length > MAX_HISTORY) page.history.shift(); else page.historyStep++;
        }
        function undo() { if (state.selection.active) stampSelection(); const page = state.pages[state.activePageIndex]; if (page && page.historyStep > 0) { page.historyStep--; restoreState(page); triggerSave(); } }
        function redo() { if (state.selection.active) stampSelection(); const page = state.pages[state.activePageIndex]; if (page && page.historyStep < page.history.length - 1) { page.historyStep++; restoreState(page); triggerSave(); } }
        function restoreState(page) { if (!page.history[page.historyStep]) { page.ctx.clearRect(0, 0, page.canvas.width, page.canvas.height); return; } const img = new Image(); img.src = page.history[page.historyStep]; img.onload = () => { page.ctx.save(); page.ctx.setTransform(1, 0, 0, 1, 0, 0); page.ctx.clearRect(0, 0, page.canvas.width, page.canvas.height); page.ctx.drawImage(img, 0, 0); page.ctx.restore(); }; }
        function clearCanvas() { if(state.selection.active) stampSelection(); const page = state.pages[state.activePageIndex]; if (!page) return; page.ctx.save(); page.ctx.setTransform(1, 0, 0, 1, 0, 0); page.ctx.clearRect(0, 0, page.canvas.width, page.canvas.height); page.ctx.restore(); saveStateToPage(state.activePageIndex); triggerSave(); }
        function getCompositedCanvas(sourceCanvas) { const tempCanvas = document.createElement('canvas'); tempCanvas.width = sourceCanvas.width; tempCanvas.height = sourceCanvas.height; const ctx = tempCanvas.getContext('2d'); ctx.fillStyle = '#18181b'; ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height); ctx.drawImage(sourceCanvas, 0, 0); return tempCanvas; }
        function downloadCanvas() { if(state.selection.active) stampSelection(); const page = state.pages[state.activePageIndex]; if(!page) return; const composite = getCompositedCanvas(page.canvas); const link = document.createElement('a'); link.download = `whiteboard-p${state.activePageIndex+1}.png`; link.href = composite.toDataURL('image/png'); link.click(); }
        function deleteSelection() { if (!state.selection.active) return; liftSelection(); state.selection.active = false; state.selection.image = null; state.lassoPath = []; selectionUi.classList.remove('active'); saveStateToPage(state.activePageIndex); triggerSave(); }
        function stampSelection() { if (!state.selection.active) return; if (state.selection.image) { const page = state.pages[state.selection.pageIndex]; const dpr = window.devicePixelRatio || 1; page.ctx.drawImage(state.selection.image, state.selection.x * dpr, state.selection.y * dpr); } state.selection.active = false; state.selection.image = null; state.lassoPath = []; selectionUi.classList.remove('active'); saveStateToPage(state.selection.pageIndex); triggerSave(); }
        function updateSelectionVisuals() { const ui = selectionUi; const s = state.selection; const page = state.pages[s.pageIndex]; if (s.active && page) { ui.style.left = `${page.canvas.offsetLeft + s.x}px`; ui.style.top = `${page.canvas.offsetTop + s.y}px`; ui.style.width = `${s.w}px`; ui.style.height = `${s.h}px`; ui.classList.add('active'); } else ui.classList.remove('active'); }
        function renderSelectionMove() { if (!state.selection.image) return; const page = state.pages[state.selection.pageIndex]; const dpr = window.devicePixelRatio || 1; page.ctx.save(); page.ctx.setTransform(1, 0, 0, 1, 0, 0); page.ctx.clearRect(0, 0, page.canvas.width, page.canvas.height); page.ctx.drawImage(baseCanvas, 0, 0); page.ctx.drawImage(state.selection.image, state.selection.x * dpr, state.selection.y * dpr); page.ctx.restore(); }
        function selectAll() { if (state.selection.active) stampSelection(); const page = state.pages[state.activePageIndex]; if (!page) return; const dpr = window.devicePixelRatio || 1; const w = page.canvas.width / dpr; const h = page.canvas.height / dpr; const selCanvas = document.createElement('canvas'); selCanvas.width = page.canvas.width; selCanvas.height = page.canvas.height; const selCtx = selCanvas.getContext('2d'); selCtx.drawImage(page.canvas, 0, 0); state.selection = { active: true, pageIndex: state.activePageIndex, x: 0, y: 0, w: w, h: h, image: selCanvas }; page.ctx.clearRect(0, 0, page.canvas.width, page.canvas.height); baseCanvas.width = page.canvas.width; baseCanvas.height = page.canvas.height; let baseCtx = baseCanvas.getContext('2d'); baseCtx.clearRect(0, 0, baseCanvas.width, baseCanvas.height); state.mode = 'SELECTION_ACTIVE'; updateSelectionVisuals(); }

        window.addEventListener('load', init);
        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') { e.preventDefault(); selectAll(); }
            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelection();
            if (e.code === 'Space' && !state.isSpaceBarDown) { state.isSpaceBarDown = true; if(state.mode === 'IDLE') scrollView.classList.add('cursor-pan'); }
        });
        window.addEventListener('keyup', (e) => { if (e.code === 'Space') { state.isSpaceBarDown = false; scrollView.classList.remove('cursor-pan'); } });
    </script>
</body>
</html>
